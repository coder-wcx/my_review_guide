redis：
    数据结构：
        sds:
            包含 buf 、free 、len
            1.常数时间获取字符串长度
            2.避免缓冲区溢出，因为本质是C的字符串不能够知道字符串的大小，预分配的内存空间不足以拼接
            3.通过free未分配的空间，sds实现了空间预分配和惰性空间释放两种策略 
                空间预分配：相当于分配时，长度多大 free也多大，比如len=13 那么free=13 那么总体的sds大小为13+ 13+1= 27字节
                惰性空间释放:删除时，把腾出来的记作free,下次分配时避免扩大
            4.二进制安全
        链表:
            双向链表(node -> pre next value)
            发布与订阅、慢查询、监视器也用到链表结构
        字典:
            一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。
            dictEntry:
                key属性保存着键值对中的键，而v属性则保存着键值对中的值，
                其中键值对的值可以是一个指针，或者是一个uint64_t整数，又或者是一个int64_t整数。
                next属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一次，
                以此来解决键冲突（collision）的问题。
            hash算法:murmurhash,随机性好，速度快
            hash冲突: 链地址法解决
            rehash: 通过ht[0],ht[1]来进行 ,负载因子 = ht[0].used / ht[1].size
            渐进式rehash:通过rehashIndex -> 在rehash过程中 发生crud,逐步都会将ht[0]对应的数据 操作到ht[1],避免了集中操作的巨大计算量
                在rehash过程中，删除、查找、更新都会在ht[0],ht[1]进行，而新增的值只会放在ht[1];
        跳表:
            是一种有序的 ，在每个节点维护多个指向其他节点的指针，快速访问
            作用:有序集合键，集群节点中用作内部数据结构
            跳跃表是有序集合的底层实现之一。
            Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成，
            其中zskiplist用于保存跳跃表信息（比如表头节点、表尾节点、长度），
            而zskiplistNode则用于表示跳跃表节点。
            每个跳跃表节点的层高都是1至32之间的随机数。
            在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的。
            跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序。
        整数集合(intset):
            整数升级(当集合内新增较大的数字时，会进行升级，encoding变更)
            整数降级不支持
        压缩列表:
            列表键和哈希键的实现之一;
            压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构
    
    对象:
        字符串对象:
            小于32:为embstr 大于32:为raw
            embstr:只会通过一次分配内存，而raw会分配两次
            redisObject和sdshdr
            embstr是一种只读格式，一但有修改就会转成raw
        列表对象: 
            ziplist/linkedlist
            3.2版本后使用quicklist 
        哈希对象:
            ziplist、hashtable
            hash对象的key,value都小于64，或者size小于512使用ziplist
        集合对象:
            intset/hashtable
            使用数字的时候或者数量少于512，都是intset,非数值都是hashtable
        有序集合对象:
            ziplist/skiplist
            长度小于64，size小于128使用ziplist

    垃圾回收:
        对象的生命周期:创建对象，操作对象，释放对象
        使用引用计数法实现垃圾回收
    对象共享:
        只共享整数型的数据，因为字符串的验证为O(n)，整数型为o(1)

    空转:
        当key一直没被使用，通过object idletime key 查看空转时间 
    命令:
        set key value;
        setex key ttl value;
        expire key time;
        pexpire key time(ms)
        expireat key time(在这个时间戳之前)
        pexprireat key time(在这个时间戳(ms)之前) 
        过期相关的都是基于pexprireat实现
    过期时间用一个过期字典维护
    过期键删除策略:
        1.定时删除，到过期时间立即删除 对内存友好，对Cpu不友好
        2.惰性删除，放任不管，调用过期才删除 对CPU友好，对内存不友好 ✅
        3.定期删除，每隔一段时间，定期扫描，删除过期键 ✅
        expireIfNeeded() 惰性删除，在实际调用get等命令时都会调用此函数
        activeExpireCycle() 定期删除

    生成RDB文件:
        save()/bgsave() 会生成一个新的rdb，新文件不会包含过期键
    载入RDB文件:
        主服务器不会载入过期的
        从服务器会载入过期的
    
    AOF文件写入:
        bgwriteaof:
        当触发到过期时，都会append一条delete命令，显性删除
    AOF文件重写:
        已过期的都不会载入

    AOF优先级高于RDB
    复制:
        主服务器删除 -> 发送一个del命令到从服务器 -> 只有接收到del命令才会删除
    

    数据库通知:
        key-space-notification:键空间通知
        key-event-notification:键事件通知
    
    dirty计数器:记录修改了库多少次

    aof的appendfsync策略: 对aof_buffer缓存区的数据进行写入到aof文件
        always:
        everysec:
        no:

    aof:数据恢复流程:
    1.创建一个不带网络连接的伪客户端
    2.从AOF文件分析，读取出写命令
    3.伪客户端执行写命令
    4.重复2.3

    aof重写 BGREWRITEAOF:
        避免aof文件膨胀过大，将一些可以合并的命令合并，生成新的aof文件
        注意：如果合并的命令过大超过客户端输入缓存大小，那么就会拆分成多个命令
        REDIS_AOF_REWRITE_ITEMS_PER_CMD = 64

        使用子进程：
            1.在子进程进行aof重写时，主进程还能继续处理命令请求
            2.子进程带有服务器进程的副本，不使用线程，可以保证避免用锁的情况下，保证数据的安全性
            引出的问题：
                导致当前服务器的状态和重写后的aof文件保存的服务器状态不一致
                解决:
                    在子进程进行aof重写时，服务器会进行
                    1.执行客户端发送的命令
                    2.将执行的命令追加到aof缓冲区
                    3.将执行的命令追加到aof重写缓冲区

    
    事件:
        redis服务器是一个事件驱动程序:
            1.文件事件(file event):
            2.时间事件(time event):

    


    redis集群模式：
        主从复制:
            一主多从: 分担主服务的压力
        哨兵模式:
            master 挂掉的话，sentinel会选举一个master，选举的过程是不可访问redis，会出现访问瞬断

        cluster模式:
            多个主从节点群组成，具有复制、高可用、分片特性
            cluster槽:
                槽的数量为16384(2^14)，因为在节点中交换数据中有myslots[Cluster_slots/8]
                如果槽数量过大,那么传输的大小就变大
                假设槽的大小为65536(2 ^ 16)
                那么myslots的大小为65536 / 8 / 1024 == 8kb
                发送心跳信息的消息头达8k，发送的心跳包过于庞大。
                同时节点不会过多，1000个以内的节点16384个就够了，没必要到

                拓展:
                    一致性hash算法:
                        在节点增加或者减少的时候，都会对原有的节点hash值造成影响
                        在移除或者添加一个服务器时，能够尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系。一致性哈希解决了简单哈希算法在分布式哈希表（Distributed Hash Table，DHT）中存在的动态伸缩等问题 。

                    与普通hash算法的关系:
                        在分布式环境下，应当满足以下条件:
                            1.平衡性 平均分布，满足负载均衡策略
                            2.单调性 在节点数量变化时，不影响已有节点的位置
                            3.分散性 
                    实现:
                        使用的是一致性哈希环 [0, 2^32-1]
                    虚拟节点:
                        解决新增节点时，新增节点只解放了临近节点的负载压力，其余节点并没有新节点的加入而降低压力
                        即将每台物理服务器虚拟为一组虚拟服务器，将虚拟服务器放置到哈希环上，如果要确定对象的服务器，需先确定对象的虚拟服务器，再由虚拟服务器确定物理服务器。

    布隆过滤器:
        实际上是一个很长的二进制向量和一系列的随机映射函数
        优点:
            空间效率和查询效率都比一般的要好
        缺点:
            有一定的误识别，和删除困难
        检测的值是可能存在的值和一定不存在的值，存在一定的误判率