mysql:
    逻辑分层:
        服务层:主要连接处理，授权认证，安全等
        核心服务层: 包括查询解析，分析，优化，缓存 以及内置函数
        存储引擎层： 
    
    锁:
        表锁:
        行锁:
            读锁:共享锁
            写锁:排它锁
            意向共享锁(IS): 一个事务给一个数据行加共享锁时，必须先获得表的IS锁
            意向排它锁(IX): 一个事务给一个数据行加排他锁时，必须先获得该表的IX锁
        页锁:只在存储引擎层，innodb
        record lock:单个行记录的锁，总会锁住索引记录，如果没有索引，那么会使用隐形的主键进行锁定

        gap lock:
        存在值，唯一索引只会产生记录锁,如果查询不存在的数据，那么也会产生记录锁和间隙锁
        普通索引列上，不管是何种查询，只要加锁，都会产生间隙锁，这跟唯一索引不一样；
        next-key lock:记录锁和间隙锁的组合，它的封锁范围既包含索引记录，又包含索引区间
        临建锁主要目的是为了避免幻读，但是如果把事务隔离级别修改为RC ，临建锁也失效
    事务:
        ACID
        原子性:
        一致性:
        隔离性:
        持久性:
        带来的问题：
            1.更新丢失
            2.脏读 
            3.不可重复读 next-key 
            4.幻读 间隙锁解决
    隔离级别:
        读未提交 RU 脏读 不可重复读 幻读
        读已提交 RC 不可重复读 幻读
        可重复读 RR 幻读
        串行化
    select * from 。。。 :快照读(一致性读，无锁)
        不同隔离级别机制不同:
            RC:事务中的每个一致读取都会设置并读取自己的新快照。
            RR:同一个事务的所有一致性读取都会读取该事务中的第一次读建立的快照
    select * from ...for update : 当前读(锁定读，有锁)
    MVCC(多版本并发控制，可以使用快照度，不会被阻塞):只在读已提交，可重复读中有。没行记录都保存两个隐藏的列来实现，一个创建时间，一个行的过期时间。 
    解决不可重复读: 通过Mvcc版本比较，解决不可重复读的问题，事务会访问到另一个事务开辟Undo区域，保证后一次读和前一次读的结果相同；再加上写锁的排他特性，保证同一时刻，只会有一个事务可以操作某一行数据 当然，RR级别才有可重复读能力，RC级别是会不可重复读的
    解决幻读: 通过行锁 + 间隙gap锁,这里说的行锁是通过mvcc实现的乐观锁，比较cache页中数据行的version和当前事务的version，如果当前version比较小，则去undo区域，在普通select读这种快照读情况下，实际上是不会有锁的，而在dml中，涉及到数据变更，会锁住被修改的行，同时，加gap锁，防止其他事务插入数据导致的幻读